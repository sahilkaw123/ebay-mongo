// Generated by CoffeeScript 1.10.0
(function() {
  var AMQPCLI, amqp, cli;

  amqp = require('amqp');

  AMQPCLI = (function() {
    function AMQPCLI() {}

    AMQPCLI.prototype.report_error = function(message_suffix, err, status) {
      if (status == null) {
        status = 1;
      }
      console.error("[ERROR] Error encountered " + message_suffix);
      console.error(err);
      console.error(err.stack);
      return process.exit(status);
    };

    AMQPCLI.prototype.report_success = function(type, message_suffix, status) {
      if (status == null) {
        status = 0;
      }
      console.log(type + " " + message_suffix);
      return process.exit(status);
    };

    AMQPCLI.prototype.open_connection = function(broker_url, connection_options) {
      var connection;
      connection = amqp.createConnection({
        url: broker_url
      }, connection_options);
      connection.once('error', (function(_this) {
        return function(err) {
          return _this.report_error("while connecting to broker at \"" + broker_url + "\".", err);
        };
      })(this));
      return connection;
    };

    AMQPCLI.prototype.log_connection = function(broker_url, connection_options) {
      var connection;
      connection = this.open_connection(broker_url, connection_options);
      return connection.once('ready', (function(_this) {
        return function() {
          console.log(connection);
          return _this.report_success("[LOG]", "logged.");
        };
      })(this));
    };

    AMQPCLI.prototype.log_exchange = function(broker_url, connection_options, exchange_name) {
      var connection;
      connection = this.open_connection(broker_url, connection_options);
      return connection.once('ready', (function(_this) {
        return function() {
          var exchange, exchange_options;
          exchange_options = {
            passive: true,
            noDeclare: true
          };
          exchange = connection.exchange(exchange_name, exchange_options, function(exchange) {
            console.log(exchange);
            return _this.report_success("[LOG]", "logged.");
          });
          return exchange.once('error', function(err) {
            return _this.report_error("Exchange named \"" + exchange_name + "\" was NOT found.", err);
          });
        };
      })(this));
    };

    AMQPCLI.prototype.log_queue = function(broker_url, connection_options, queue_name) {
      var connection;
      connection = this.open_connection(broker_url, connection_options);
      return connection.once('ready', (function(_this) {
        return function() {
          var queue, queue_options;
          queue_options = {
            passive: true,
            noDeclare: true
          };
          queue = connection.queue(queue_name, queue_options, function(queue) {
            console.log(queue);
            return _this.report_success("[LOG]", "logged.");
          });
          return queue.once('error', function(err) {
            return _this.report_error("Queue named \"" + queue_name + "\" was NOT found.", err);
          });
        };
      })(this));
    };

    AMQPCLI.prototype.create_exchange = function(broker_url, connection_options, exchange_name, exchange_options) {
      var connection;
      connection = this.open_connection(broker_url, connection_options);
      return connection.once('ready', (function(_this) {
        return function() {
          var exchange;
          exchange = connection.exchange(exchange_name, exchange_options, function(exchange) {
            return _this.report_success("[SUCCESS]", "Exchange named \"" + exchange_name + "\" created (or found).");
          });
          return exchange.once('error', function(err) {
            return _this.report_error("while creating exchange named \"" + exchange_name + "\".", err);
          });
        };
      })(this));
    };

    AMQPCLI.prototype.check_exchange = function(broker_url, connection_options, exchange_name) {
      var connection;
      connection = this.open_connection(broker_url, connection_options);
      return connection.once('ready', (function(_this) {
        return function() {
          var exchange, exchange_options;
          exchange_options = {
            passive: true,
            noDeclare: true
          };
          exchange = connection.exchange(exchange_name, exchange_options, function(exchange) {
            return _this.report_success("[FOUND]", "Exchange named \"" + exchange_name + "\" was found.");
          });
          return exchange.once('error', function(err) {
            return _this.report_success("[NOT FOUND]", "Exchange named \"" + exchange_name + "\" was NOT found.");
          });
        };
      })(this));
    };

    AMQPCLI.prototype.destroy_exchange = function(broker_url, connection_options, exchange_name, only_if_unused) {
      var connection;
      connection = this.open_connection(broker_url, connection_options);
      return connection.once('ready', (function(_this) {
        return function() {
          var exchange, exchange_options;
          exchange_options = {
            passive: true,
            noDeclare: true
          };
          exchange = connection.exchange(exchange_name, exchange_options, function(exchange) {
            exchange.once('error', function(err) {
              return _this.report_error("while destroying exchange named \"" + exchange_name + "\".");
            });
            exchange.once('exchangeDeleteOk', function(err) {
              return _this.report_success("[DELETED]", "Exchange named \"" + exchange_name + "\" deleted.");
            });
            return exchange.destroy(only_if_unused);
          });
          return exchange.once('error', function(err) {
            return _this.report_success("[GONE]", "Exchange named \"" + exchange_name + "\" already didn't exist.");
          });
        };
      })(this));
    };

    AMQPCLI.prototype.create_queue = function(broker_url, connection_options, queue_name, queue_options) {
      var connection;
      connection = this.open_connection(broker_url, connection_options);
      return connection.once('ready', (function(_this) {
        return function() {
          var queue;
          queue = connection.queue(queue_name, queue_options, function(queue) {
            return _this.report_success("[SUCCESS]", "Queue named \"" + queue_name + "\" created (or found).");
          });
          return queue.once('error', function(err) {
            return _this.report_error("while creating queue named \"" + queue_name + "\".", err);
          });
        };
      })(this));
    };

    AMQPCLI.prototype.check_queue = function(broker_url, connection_options, queue_name) {
      var connection;
      connection = this.open_connection(broker_url, connection_options);
      return connection.once('ready', (function(_this) {
        return function() {
          var queue, queue_options;
          queue_options = {
            passive: true,
            noDeclare: true
          };
          queue = connection.queue(queue_name, queue_options, function(queue) {
            return _this.report_success("[FOUND]", "Queue named \"" + queue_name + "\" was found.");
          });
          return queue.once('error', function(err) {
            return _this.report_success("[NOT FOUND]", "Queue named \"" + queue_name + "\" was NOT found.");
          });
        };
      })(this));
    };

    AMQPCLI.prototype.destroy_queue = function(broker_url, connection_options, queue_name, only_if_unused, only_if_empty) {
      var connection;
      connection = this.open_connection(broker_url, connection_options);
      return connection.once('ready', (function(_this) {
        return function() {
          var queue, queue_options;
          queue_options = {
            passive: true,
            noDeclare: true
          };
          queue = connection.queue(queue_name, queue_options, function(queue) {
            queue.once('queueDeleteOk', function(err) {
              return _this.report_success("[DELETED]", "Queue named \"" + queue_name + "\" deleted.");
            });
            queue.once('error', function(err) {
              return _this.report_error("while destroying queue named \"" + queue_name + "\".");
            });
            return queue.destroy({
              ifUnused: only_if_unused,
              ifEmpty: only_if_empty
            });
          });
          return queue.once('error', function(err) {
            return _this.report_success("[GONE]", "Queue named \"" + queue_name + "\" already didn't exist.");
          });
        };
      })(this));
    };

    AMQPCLI.prototype.bind_queue = function(broker_url, connection_options, queue_name, exchange_name, routing_key) {
      var connection;
      connection = this.open_connection(broker_url, connection_options);
      return connection.once('ready', (function(_this) {
        return function() {
          var exchange, exchange_options;
          exchange_options = {
            passive: true,
            noDeclare: true
          };
          exchange = connection.exchange(exchange_name, exchange_options, function(exchange) {
            var queue, queue_options;
            queue_options = {
              passive: true,
              noDeclare: true
            };
            queue = connection.queue(queue_name, queue_options, function(queue) {
              queue.once('error', function(err) {
                return _this.report_error("while binding queue named \"" + queue_name + "\" to exchange named \"" + exchange_name + "\" using routing key \"" + routing_key + "\".", err);
              });
              queue.once('queueBindOk', function(err) {
                return _this.report_success("[BOUND]", "Queue named \"" + queue_name + "\" was bound to exchange named \"" + exchange_name + "\" using routing key \"" + routing_key + "\".");
              });
              return queue.bind(exchange, routing_key);
            });
            return queue.once('error', function(err) {
              return _this.report_error("Queue named \"" + queue_name + "\" was NOT found.", err);
            });
          });
          return exchange.once('error', function(err) {
            return _this.report_error("Exchange named \"" + exchange_name + "\" was NOT found.", err);
          });
        };
      })(this));
    };

    AMQPCLI.prototype.unbind_queue = function(broker_url, connection_options, queue_name, exchange_name, routing_key) {
      var connection;
      connection = this.open_connection(broker_url, connection_options);
      return connection.once('ready', (function(_this) {
        return function() {
          var exchange, exchange_options;
          exchange_options = {
            passive: true,
            noDeclare: true
          };
          exchange = connection.exchange(exchange_name, exchange_options, function(exchange) {
            var queue, queue_options;
            queue_options = {
              passive: true,
              noDeclare: true
            };
            queue = connection.queue(queue_name, queue_options, function(queue) {
              queue.once('error', function(err) {
                return _this.report_error("while unbinding queue named \"" + queue_name + "\" from exchange named \"" + exchange_name + "\" using routing key \"" + routing_key + "\".", err);
              });
              queue.once('queueUnbindOk', function(err) {
                return _this.report_success("[UNBOUND]", "Queue named \"" + queue_name + "\" was unbound from exchange named \"" + exchange_name + "\" using routing key \"" + routing_key + "\".");
              });
              return queue.unbind(exchange, routing_key);
            });
            return queue.once('error', function(err) {
              return _this.report_error("Queue named \"" + queue_name + "\" was NOT found.", err);
            });
          });
          return exchange.once('error', function(err) {
            return _this.report_error("Exchange named \"" + exchange_name + "\" was NOT found.", err);
          });
        };
      })(this));
    };

    AMQPCLI.prototype.connection_options_from_argv = function(argv) {
      var opts;
      opts = {};
      return opts;
    };

    AMQPCLI.prototype.exchange_options_from_argv = function(argv) {
      var opts, ref, ref1, ref2, ref3, ref4, ref5;
      opts = {};
      if (((ref = argv.exchange) != null ? ref.type : void 0) != null) {
        opts.type = argv.exchange.type;
      }
      if (((ref1 = argv.exchange) != null ? ref1.passive : void 0) != null) {
        opts.passive = argv.exchange.passive;
      }
      if (((ref2 = argv.exchange) != null ? ref2.durable : void 0) != null) {
        opts.durable = argv.exchange.durable;
      }
      if (((ref3 = argv.exchange) != null ? ref3.confirm : void 0) != null) {
        opts.confirm = argv.exchange.confirm;
      }
      if (((ref4 = argv.exchange) != null ? ref4['auto-delete'] : void 0) != null) {
        opts.autoDelete = argv.exchange['auto-delete'];
      }
      if (((ref5 = argv.exchange) != null ? ref5['no-declare'] : void 0) != null) {
        opts.noDeclare = argv.exchange['no-declare'];
      }
      return opts;
    };

    AMQPCLI.prototype.queue_options_from_argv = function(argv) {
      var opts, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7;
      opts = {};
      if (((ref = argv.queue) != null ? ref.passive : void 0) != null) {
        opts.passive = argv.queue.passive;
      }
      if (((ref1 = argv.queue) != null ? ref1.durable : void 0) != null) {
        opts.durable = argv.queue.durable;
      }
      if (((ref2 = argv.queue) != null ? ref2.exclusive : void 0) != null) {
        opts.exclusive = argv.queue.exclusive;
      }
      if (((ref3 = argv.queue) != null ? ref3['auto-delete'] : void 0) != null) {
        opts.autoDelete = argv.queue['auto-delete'];
      }
      if (((ref4 = argv.queue) != null ? ref4.durable : void 0) != null) {
        opts.durable = argv.queue.durable;
      }
      if (((ref5 = argv.queue) != null ? ref5['no-declare'] : void 0) != null) {
        opts.noDeclare = argv.queue['no-declare'];
      }
      if (((ref6 = argv.queue) != null ? ref6["arguments"] : void 0) != null) {
        opts["arguments"] = JSON.parse(argv.queue["arguments"]);
      }
      if (((ref7 = argv.queue) != null ? ref7['close-channel-on-unsubscribe'] : void 0) != null) {
        opts.closeChannelOnUnsubscribe = argv.queue['close-channel-on-unsubscribe'];
      }
      return opts;
    };

    AMQPCLI.prototype.main = function() {
      var argv, broker, conn_opts, only_if_empty, only_if_unused, optimist, opts, ref, ref1, ref10, ref11, ref12, ref13, ref14, ref15, ref16, ref17, ref18, ref19, ref2, ref20, ref21, ref22, ref23, ref3, ref4, ref5, ref6, ref7, ref8, ref9;
      optimist = require('optimist').options({
        'h': {
          alias: 'help',
          boolean: true,
          describe: "Show help"
        },
        'b': {
          alias: 'broker',
          "default": 'amqp://guest:guest@localhost:5672',
          describe: "Message broker to connect to"
        },
        'e.name': {
          alias: 'exchange.name',
          describe: "Exchange name."
        },
        'e.type': {
          alias: 'exchange.type',
          "default": 'topic',
          describe: "If set when creating a new exchange, the exchange will be of the indicated type (direct, fanout or topic)."
        },
        'e.passive': {
          alias: 'exchange.passive',
          boolean: true,
          describe: "If set, the server will not create the exchange if it doesn't already exist."
        },
        'e.durable': {
          alias: 'exchange.durable',
          boolean: true,
          describe: "If set when creating a new exchange, the exchange will be marked as durable."
        },
        'e.confirm': {
          alias: 'exchange.confirm',
          boolean: true,
          describe: "If set when creating a new exchange, the exchange will be in confirm mode."
        },
        'e.auto-delete': {
          alias: 'exchange.auto-delete',
          boolean: true,
          describe: "If set, the exchange is deleted when there are no longer queues bound to it."
        },
        'e.only-if-unused': {
          alias: 'exchange.only-if-unused',
          boolean: true,
          describe: "If set when destroying an exchange, the exchange is deleted only if there are no queues bound to it."
        },
        'q.name': {
          alias: 'queue.name',
          describe: "Queue name."
        },
        'q.passive': {
          alias: 'queue.passive',
          boolean: true,
          describe: "If set, the server will not create the queue if it doesn't already exist."
        },
        'q.durable': {
          alias: 'queue.durable',
          boolean: true,
          describe: "If set when creating a new queue, the queue will be marked as durable."
        },
        'q.auto-delete': {
          alias: 'queue.auto-delete',
          boolean: true,
          describe: "If set when creating an new queue, the queue is deleted when all consumers have finished using it."
        },
        'q.no-declare': {
          alias: 'queue.no-declare',
          boolean: true,
          describe: "If set, the queue will not be declared."
        },
        'q.only-if-empty': {
          alias: 'queue.only-if-empty',
          boolean: true,
          describe: "If set when destroying a queue, the queue is deleted only if there are no messages pending within it."
        },
        'q.only-if-unused': {
          alias: 'queue.only-if-unused',
          boolean: true,
          describe: "If set when destroying a queue, the queue is deleted only if there are no consumers subscribed to it."
        },
        'k': {
          alias: 'routing-key',
          "default": '*',
          describe: "When binding a queue to an exchange, the routing key value to bind with."
        }
      }).usage('Usage: $0 [check|create|destroy|bind|unbind] [exchange|queue] [OPTIONS]');
      argv = optimist.argv;
      if (optimist.argv.help || optimist.argv._.length === 0 || optimist.argv._[0] === 'help') {
        console.log("");
        console.log("A command line tool for manipulating AMQP Queues and Exchanges.");
        console.log("");
        optimist.showHelp();
        console.log("");
        console.log("Examples:");
        console.log(" " + optimist['$0'] + " create exchange --e.name my-exchange");
        console.log("   creates a new exchange named \"my-exchange\" (unless it already exists).");
        console.log(" " + optimist['$0'] + " create queue --q.name my-queue");
        console.log("   creates a new queue named \"my-queue\" (unless it already exists).");
        console.log(" " + optimist['$0'] + " bind queue --q.name my-queue --e.name my-exchange");
        console.log("   binds the queue named \"my-queue\" to the exchange named \"my-exchange\".");
        console.log("");
        console.log("Also see");
        console.log("  https://github.com/postwait/node-amqp/");
        console.log("for more detail on the parameters above, or");
        console.log("  rabbitmqctl");
        console.log("for a more sophisticated client for working with a RabbitMQ broker.");
        console.log("");
        return process.exit();
      } else {
        broker = argv.broker;
        conn_opts = this.connection_options_from_argv(argv);
        switch (optimist.argv._[0]) {
          case 'log':
            switch (optimist.argv._[1]) {
              case 'exchange':
                if (!(((ref = argv.exchange) != null ? (ref1 = ref.name) != null ? ref1.length : void 0 : void 0) > 0)) {
                  console.error("Exchange name is required when logging an exchange. Use --help for help.");
                  return process.exit(1);
                } else {
                  return this.log_exchange(broker, conn_opts, argv.exchange.name);
                }
                break;
              case 'queue':
                if (!(((ref2 = argv.queue) != null ? (ref3 = ref2.name) != null ? ref3.length : void 0 : void 0) > 0)) {
                  console.error("Queue name is required when logging a queue. Use --help for help.");
                  return process.exit(1);
                } else {
                  return this.log_queue(broker, conn_opts, argv.queue.name);
                }
                break;
              case 'connection':
              case 'channel':
                return this.log_connection(broker, conn_opts);
              default:
                console.error("OBJECT", optimist.argv._[1], "NOT RECOGNIZED HERE.");
                return process.exit(1);
            }
            break;
          case 'bind':
            switch (optimist.argv._[1]) {
              case 'queue':
                if (!(((ref4 = argv.queue) != null ? (ref5 = ref4.name) != null ? ref5.length : void 0 : void 0) > 0)) {
                  console.error("Queue name is required when binding a queue. Use --help for help.");
                  process.exit(1);
                }
                if (!(((ref6 = argv.exchange) != null ? (ref7 = ref6.name) != null ? ref7.length : void 0 : void 0) > 0)) {
                  console.error("Exchange name is required when binding a queue. Use --help for help.");
                  return process.exit(1);
                } else {
                  return this.bind_queue(broker, conn_opts, argv.queue.name, argv.exchange.name, argv['routing-key']);
                }
                break;
              default:
                console.error("OBJECT", optimist.argv._[1], "NOT RECOGNIZED HERE.");
                return process.exit(1);
            }
            break;
          case 'unbind':
            switch (optimist.argv._[1]) {
              case 'queue':
                if (!(((ref8 = argv.queue) != null ? (ref9 = ref8.name) != null ? ref9.length : void 0 : void 0) > 0)) {
                  console.error("Queue name is required when unbinding a queue. Use --help for help.");
                  process.exit(1);
                }
                if (!(((ref10 = argv.exchange) != null ? (ref11 = ref10.name) != null ? ref11.length : void 0 : void 0) > 0)) {
                  console.error("Exchange name is required when unbinding a queue. Use --help for help.");
                  return process.exit(1);
                } else {
                  return this.unbind_queue(broker, conn_opts, argv.queue.name, argv.exchange.name, argv['routing-key']);
                }
                break;
              default:
                console.error("OBJECT", optimist.argv._[1], "NOT RECOGNIZED HERE.");
                return process.exit(1);
            }
            break;
          case 'create':
            switch (optimist.argv._[1]) {
              case 'exchange':
                if (!(((ref12 = argv.exchange) != null ? (ref13 = ref12.name) != null ? ref13.length : void 0 : void 0) > 0)) {
                  console.error("Exchange name is required when creating an exchange. Use --help for help.");
                  return process.exit(1);
                } else {
                  opts = this.exchange_options_from_argv(argv);
                  return this.create_exchange(broker, conn_opts, argv.exchange.name, opts);
                }
                break;
              case 'queue':
                if (!(((ref14 = argv.queue) != null ? (ref15 = ref14.name) != null ? ref15.length : void 0 : void 0) > 0)) {
                  console.error("Queue name is required when creating a queue. Use --help for help.");
                  return process.exit(1);
                } else {
                  opts = this.queue_options_from_argv(argv);
                  return this.create_queue(broker, conn_opts, argv.queue.name, opts);
                }
                break;
              default:
                console.error("OBJECT", optimist.argv._[1], "NOT RECOGNIZED HERE.");
                return process.exit(1);
            }
            break;
          case 'check':
            switch (optimist.argv._[1]) {
              case 'exchange':
                if (!(((ref16 = argv.exchange) != null ? (ref17 = ref16.name) != null ? ref17.length : void 0 : void 0) > 0)) {
                  console.error("Exchange name is required when checking an exchange. Use --help for help.");
                  return process.exit(1);
                } else {
                  return this.check_exchange(broker, conn_opts, argv.exchange.name);
                }
                break;
              case 'queue':
                if (!(((ref18 = argv.queue) != null ? (ref19 = ref18.name) != null ? ref19.length : void 0 : void 0) > 0)) {
                  console.error("Queue name is required when checking a queue. Use --help for help.");
                  return process.exit(1);
                } else {
                  return this.check_queue(broker, conn_opts, argv.queue.name);
                }
                break;
              default:
                console.error("OBJECT", optimist.argv._[1], "NOT RECOGNIZED HERE.");
                return process.exit(1);
            }
            break;
          case 'delete':
          case 'destroy':
            switch (optimist.argv._[1]) {
              case 'exchange':
                if (!(((ref20 = argv.exchange) != null ? (ref21 = ref20.name) != null ? ref21.length : void 0 : void 0) > 0)) {
                  console.error("Exchange name is required when destroying an exchange. Use --help for help.");
                  return process.exit(1);
                } else {
                  only_if_unused = argv.exchange['only-if-unused'];
                  return this.destroy_exchange(broker, conn_opts, argv.exchange.name, only_if_unused);
                }
                break;
              case 'queue':
                if (!(((ref22 = argv.queue) != null ? (ref23 = ref22.name) != null ? ref23.length : void 0 : void 0) > 0)) {
                  console.error("Queue name is required when destroying a queue. Use --help for help.");
                  return process.exit(1);
                } else {
                  only_if_unused = argv.queue['only-if-unused'];
                  only_if_empty = argv.queue['only-if-empty'];
                  return this.destroy_queue(broker, conn_opts, argv.queue.name, only_if_unused, only_if_empty);
                }
                break;
              default:
                console.error("OBJECT", optimist.argv._[1], "NOT RECOGNIZED HERE.");
                return process.exit(1);
            }
            break;
          default:
            console.log("ACTION", optimist.argv._[0], "NOT RECOGNIZED HERE.");
            return process.exit(1);
        }
      }
    };

    return AMQPCLI;

  })();

  if (require.main === module) {
    cli = new AMQPCLI();
    cli.main();
  }

  exports.AMQPCLI = AMQPCLI;

}).call(this);
